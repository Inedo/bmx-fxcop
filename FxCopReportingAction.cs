using System;
using System.Collections.Generic;
using System.IO;
using Inedo.BuildMaster;
using Inedo.BuildMaster.Extensibility.Actions;
using Inedo.BuildMaster.Extensibility.Actions.Reporting;
using Inedo.BuildMaster.Web;

namespace Inedo.BuildMasterExtensions.FxCop
{
    /// <summary>
    /// FxCop reporting action
    /// </summary>
    [ActionProperties("Generate FxCop Report", "Runs FxCop and saves the output to a report.")]
    [CustomEditor(typeof(FxCopReportingActionEditor))]
    [Tag("Reporting")]
    public sealed class FxCopReportingAction : ReportingActionBase
    {
        /// <summary>
        /// The file name for the temporary report
        /// </summary>
        private const string ReportName = "fxcopreport.xml";

        /// <summary>
        /// Gets or sets the file to examine with FxCop.
        /// </summary>
        [Persistent]
        public string TestFile { get; set; }

        /// <summary>
        /// Gets or sets the custom output file generated by FxCop. If blank, a temporary file will be used.
        /// </summary>
        [Persistent]
        public string CustomOutputFile { get; set; }

        /// <summary>
        /// Gets or sets the custom output XSL file.
        /// </summary>
        [Persistent]
        public string CustomOutputXslFile { get; set; }

        /// <summary>
        /// Gets or sets the directories to search for assembly dependencies.
        /// </summary>
        [Persistent]
        public string[] DependencyDirectories { get; set; }

        /// <summary>
        /// Gets or sets the directory to search for rule set files.
        /// </summary>
        [Persistent]
        public string RuleSetDirectory { get; set; }

        /// <summary>
        /// Gets or sets the rule sets to be used for analysis. An individual rule set must start with
        /// any of the three characters "+" (enable all rules in rule set), "-" (disable all rules
        /// in the rule set), or "=" (enable all rules in the rule set and disable all other rules
        /// not defined explicitly in the rule set).
        /// </summary>
        [Persistent]
        public string[] RuleSets { get; set; }

        /// <summary>
        /// Gets or sets the rules to be used for analysis. An individual rule must start with
        /// either a "+" (enables the rule) or "-" (disables the rule).
        /// </summary>
        [Persistent]
        public string[] Rules { get; set; }

        /// <summary>
        /// Gets or sets the rule IDs to enable or disable by Namespace.CheckId. An individual 
        /// rule ID can start with either a "+" (enables the rule ID) or "-" (disables the rule ID).
        /// </summary>
        [Persistent]
        public string[] RuleIds { get; set; }

        /// <summary>
        /// Gets or sets the custom dictionary used for spelling rules.
        /// </summary>
        [Persistent]
        public string CustomDictionary { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether FxCop should generate verbose command line output.
        /// </summary>
        [Persistent]
        public bool VerboseOutput { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether FxCop should search the GAC for missing
        /// assembly references.
        /// </summary>
        [Persistent]
        public bool SearchGac { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether FxCop should missing rules or rule sets
        /// as an error and halt execution.
        /// </summary>
        [Persistent]
        public bool FailOnMissingRules { get; set; }

        /// <summary>
        /// Gets the generated report path, whether it was supplied by the user or was created temporarily by BuildMaster.
        /// </summary>
        private string GeneratedReportPath
        {
            get 
            {
                return string.IsNullOrEmpty(this.CustomOutputFile)
                        ? Path.Combine(this.Context.TempDirectory, ReportName)
                        : this.CustomOutputFile;
            }
        }

        protected override string ProcessRemoteCommand(string name, string[] args)
        {
            if (!"fxcop".Equals(name)) throw new ArgumentException("The only valid execution command for the FxCopReportingAction is \"fxcop\".", "name");
            if (args.Length != 2) throw new ArgumentException("The valid execution arguments for the FxCopReportingAction are 1:exePath and 2:workingDirectory.", "args");

            string exePath = args[0];
            string workingDir = args[1];
            string arguments = BuildArguments();

            this.LogInformation(string.Format("Executing FxCop command line: {0} {1}", exePath, arguments));

            this.ExecuteCommandLine(
                exePath,
                arguments,
                workingDir
            );

            return File.ReadAllText(this.GeneratedReportPath);
        }

        /// <summary>
        /// Builds the arguments to be passed into the FxCop command line tool based on the properties of this object.
        /// </summary>
        /// <returns>A string suited for use as the passed arguments into the FxCop command line console application.</returns>
        private string BuildArguments()
        {
            var args = new List<string>();

            // specify assembly to test
            args.Add(string.Format("/f:\"{0}\" /forceoutput", this.TestFile));

            // specify the report path, whether it's a temp path or supplied by user
            args.Add(string.Format("/out:\"{0}\"", this.GeneratedReportPath));

            // force XSL transform if one was supplied by the user
            if (!string.IsNullOrEmpty(this.CustomOutputXslFile))
                args.Add(string.Format("/outxsl:\"{0}\" /applyoutxsl", this.CustomOutputXslFile));

            foreach (string customDir in this.DependencyDirectories ?? new string[0])
                args.Add(string.Format("/directory:\"{0}\"", customDir));

            foreach (string ruleSet in this.RuleSets ?? new string[0])
                args.Add(string.Format("/ruleset:\"{0}\"", ruleSet));

            foreach (string rule in this.Rules ?? new string[0])
                args.Add(string.Format("/rule:\"{0}\"", rule));

            foreach (string ruleId in this.RuleIds ?? new string[0])
                args.Add(string.Format("/ruleid:\"{0}\"", ruleId));

            if (!string.IsNullOrEmpty(this.CustomDictionary))
                args.Add(string.Format("/dictionary:\"{0}\"", this.CustomDictionary));

            if (!string.IsNullOrEmpty(this.RuleSetDirectory))
                args.Add(string.Format("/rulesetdirectory:\"{0}\"", this.RuleSetDirectory));

            if (this.VerboseOutput)
                args.Add("/verbose");

            if (this.SearchGac)
                args.Add("/searchgac");

            if (this.FailOnMissingRules)
                args.Add("/failonmissingrules");

            // add any additional arguments supplied by the user
            args.Add(this.Arguments);

            return string.Join(" ", args.ToArray());
        }

        protected override void Execute()
        {
            var absExePath = this.ExePath;
            var absWorkingDirectory = this.Context.SourceDirectory;

            this.LogDebug("Exe Path: " + absExePath);
            this.LogDebug("Working Dir: " + absWorkingDirectory);
            string report = ExecuteRemoteCommand("fxcop", absExePath, absWorkingDirectory);

            this.SubmitReport(report);
        }

        public override ActionDescription GetActionDescription()
        {
            return new ActionDescription(
                new ShortActionDescription("Run FxCop"),
                new LongActionDescription("against ", new Hilite(this.TestFile)));
        }
    }
}
